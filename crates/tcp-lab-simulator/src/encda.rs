use anyhow::{Context, Result, anyhow};
use base64::{Engine, engine::general_purpose::STANDARD};
use des::Des;
use des::cipher::generic_array::GenericArray;
use des::cipher::{BlockDecryptMut, KeyInit};
use std::fs::File;
use std::io::{BufRead, BufReader};
use std::path::Path;

/// DES key generated by the legacy Java sender: `KeyGenerator.getInstance("DES")`
/// seeded with `"OUCnet2012$#@!"` via `SecureRandom("SHA1PRNG")`.
const ENCDA_KEY: [u8; 8] = [0x85, 0x68, 0xFD, 0x3E, 0xD9, 0x9D, 0x0D, 0x73];
const DEFAULT_GROUP_SIZE: usize = 100;

#[derive(Debug, Clone)]
pub struct EncdaDataset {
    pub groups: Vec<Vec<u8>>,
    pub group_size: usize,
}

impl EncdaDataset {
    pub fn is_empty(&self) -> bool {
        self.groups.is_empty()
    }
}

pub fn load_from_file(path: &Path) -> Result<EncdaDataset> {
    let reader = BufReader::new(
        File::open(path)
            .with_context(|| format!("Failed to open ENCDA trace {}", path.display()))?,
    );

    let mut cipher = Des::new_from_slice(&ENCDA_KEY)
        .map_err(|_| anyhow!("Failed to initialize DES cipher for ENCDA trace"))?;

    let mut current = Vec::with_capacity(DEFAULT_GROUP_SIZE);
    let mut groups = Vec::new();

    for (idx, line) in reader.lines().enumerate() {
        let line = line.with_context(|| format!("Failed to read line {}", idx + 1))?;
        if line.trim().is_empty() {
            continue;
        }
        let value = decode_value(&mut cipher, line.trim())
            .with_context(|| format!("Failed to decode line {}", idx + 1))?;
        current.push(value);
        if current.len() == DEFAULT_GROUP_SIZE {
            groups.push(current.clone());
            current.clear();
        }
    }

    if !current.is_empty() {
        groups.push(current.clone());
    }

    Ok(EncdaDataset {
        groups,
        group_size: DEFAULT_GROUP_SIZE,
    })
}

fn decode_value(cipher: &mut Des, line: &str) -> Result<u8> {
    let ciphertext = STANDARD
        .decode(line.as_bytes())
        .with_context(|| "Failed to base64 decode ENCDA line")?;
    let mut buffer = ciphertext.clone();
    for chunk in buffer.chunks_exact_mut(8) {
        let block = GenericArray::from_mut_slice(chunk);
        cipher.decrypt_block_mut(block);
    }
    remove_pkcs7_padding(&mut buffer)?;
    let text = std::str::from_utf8(&buffer)
        .with_context(|| "Decrypted ENCDA payload was not valid UTF-8")?;
    let raw: i32 = text
        .trim()
        .parse()
        .with_context(|| format!("Failed to parse ENCDA value '{}'", text.trim()))?;
    if raw < 0 {
        return Err(anyhow!("ENCDA value must be non-negative: {}", raw));
    }
    let clamped = raw.min(255) as u8;
    if raw > 255 {
        tracing::warn!(
            "ENCDA value {} exceeds byte range; clamping to {}",
            raw,
            clamped
        );
    }
    Ok(clamped)
}

fn remove_pkcs7_padding(buffer: &mut Vec<u8>) -> Result<()> {
    if buffer.is_empty() {
        return Err(anyhow!("ENCDA payload is empty after decryption"));
    }
    let pad_len = *buffer.last().unwrap() as usize;
    if pad_len == 0 || pad_len > 8 || pad_len > buffer.len() {
        return Err(anyhow!("Invalid PKCS#7 padding length"));
    }
    if !buffer[buffer.len() - pad_len..]
        .iter()
        .all(|&b| b as usize == pad_len)
    {
        return Err(anyhow!("Invalid PKCS#7 padding bytes"));
    }
    let new_len = buffer.len() - pad_len;
    buffer.truncate(new_len);
    Ok(())
}
